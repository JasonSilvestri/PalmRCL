
// scripts/export-roundtrip.ts
import * as fs from "fs";
import * as fsp from "fs/promises";
import * as path from "path";
import * as crypto from "crypto";

type Frontmatter = Record<string, unknown>;

function safeJson<T = unknown>(v: T): string {
    return JSON.stringify(v, null, 2);
}

async function ensureDir(p: string) {
    await fsp.mkdir(p, { recursive: true });
}

async function readText(file: string): Promise<string> {
    return fsp.readFile(file, "utf8");
}

function parseFrontmatterAndBody(text: string): { frontmatter: Frontmatter; body: string } {
    const fmMatch = text.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n([\s\S]*)$/);
    if (!fmMatch) return { frontmatter: {}, body: text };
    const yaml = fmMatch[1];
    const body = fmMatch[2] ?? "";
    const fm: Frontmatter = {};
    for (const line of yaml.split(/\r?\n/)) {
        const m = line.match(/^([^:#]+):\s*(.*)$/);
        if (m) {
            const key = m[1].trim();
            let val: unknown = m[2].trim();
            if (val === "true") val = true;
            else if (val === "false") val = false;
            else if (/^-?\d+(\.\d+)?$/.test(String(val))) val = Number(val);
            fm[key] = val;
        }
    }
    return { frontmatter: fm, body };
}

function sha1(data: string): string {
    return crypto.createHash("sha1").update(data).digest("hex");
}

function findAllFiles(root: string, exts: string[]): string[] {
    const out: string[] = [];
    function walk(dir: string) {
        for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
            const p = path.join(dir, entry.name);
            if (entry.isDirectory()) walk(p);
            else if (entry.isFile()) {
                const ext = path.extname(entry.name).toLowerCase();
                if (exts.includes(ext)) out.push(p);
            }
        }
    }
    if (fs.existsSync(root)) walk(root);
    return out;
}

async function main() {
    const ROOT = process.cwd();
    const OUT_DIR = path.join(ROOT, "out");
    const BUNDLES_DIR = path.join(OUT_DIR, "bundles");
    const SQL_DIR = path.join(OUT_DIR, "sql");

    await ensureDir(BUNDLES_DIR);
    await ensureDir(SQL_DIR);

    const DOCS_DIR = path.join(ROOT, "docs");
    const mdFiles = findAllFiles(DOCS_DIR, [".md", ".markdown", ".mdx"]);

    const items: any[] = [];
    for (const file of mdFiles) {
        const rel = path.relative(ROOT, file).replace(/\\/g, "/");
        const content = await readText(file);
        const { frontmatter, body } = parseFrontmatterAndBody(content);
        const id = sha1(rel + "::" + content).slice(0, 16);
        items.push({
            id,
            path: rel,
            title: (frontmatter["title"] as string) || path.basename(file),
            frontmatter,
            body
        });
    }

    const name = "palm-demo";
    const suffix = sha1(JSON.stringify(items)).slice(0, 8);
    const bundleName = `${name}-${suffix}.bundle.json`;
    const seedName = `${name}-${suffix}.seed.sql`;

    const bundle = {
        name,
        createdAt: new Date().toISOString(),
        count: items.length,
        items
    };

    await fsp.writeFile(path.join(BUNDLES_DIR, bundleName), safeJson(bundle), "utf8");

    const sqlLines: string[] = [];
    sqlLines.push("-- Minimal seed generated by export-roundtrip.ts");
    sqlLines.push("CREATE TABLE IF NOT EXISTS docs (id TEXT PRIMARY KEY, title TEXT, path TEXT);");
    for (const it of items) {
        const id = it.id.replace(/'/g, "''");
        const title = String(it.title ?? "").replace(/'/g, "''");
        const p = String(it.path ?? "").replace(/'/g, "''");
        sqlLines.push(`INSERT OR REPLACE INTO docs (id, title, path) VALUES ('${id}', '${title}', '${p}');`);
    }
    await fsp.writeFile(path.join(SQL_DIR, seedName), sqlLines.join("\n") + "\n", "utf8");

    console.log(`[export] Wrote bundle: ${path.join("out", "bundles", bundleName)}`);
    console.log(`[export] Wrote seed:   ${path.join("out", "sql", seedName)}`);
}

main().catch(err => {
    console.error("[export] Failed:", err);
    process.exit(1);
});